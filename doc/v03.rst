
==================
Version 3 Refactor
==================

Abstract Goals:

* Absolute configuration compatibility (upward compatible.)
  including all plugins.

* multi-protocol support.
  ability to put in urls for mqtt, or different amqp libraries, perhaps others.

* internally represent things in v03 messages, have something build
  v02 ones for compatibility, but operate in v03.

* less code, simpler code.
  more readable, elegant, pythonic code.
  make maintenance easier. 

while you're at it
------------------

goals of opportunity:

  * add stuff to make it work as an API?
  * potentially new plugin api to allow groups (of messages and/or files.)
  * Finish off log rotation.
  * Assume python >= 3.4 remove old cruft.
  * Assume ubuntu >= 18.04 remove old cruft.
  * Assume systemd, remove sysv integration.
  * have options adopt camelCase where possible.
  * fully async, multi-sources and sinks.
 
V02 Plugin Pain Points
----------------------

Writing plugins should be a straight-forward thing for people with a rudimentary
knowledge of python, and some understanding of the task at hand. in version 2,
writing plugins is a lot harder than it should be.  

* syntax error, v2 gives basically a binary response, either reading in the plugin worked
  or it didn't... it is very unfriendly compared to normal python.

* when a setting is put in a config file, it's value is [ value ], and not value (It's in a list.)

* weird scoping issue of import (import in main does not carry over to on_messag, need to import again.)
  what the heck is self, what the heck is parent?  these are not obvious in the plugins.

* bizarre use of python logger API... self.logger? wha?

* inability to call from python code (no API.)

* inability to *add* messages within a plugin (can only process the message you have.)

* inability to process groups of messages at a time (say for concurrent sends or 
  downloads, rather than just one at time.

* poor handling of message acknowledgements. v02 just ackowledges the previous message 
  when a new one is received.

* lack of clarity about options, versus working variables, because they are in the same namespace
  in a plugin, if you find self.setting==True  ... is that because the application set it somewhere, 
  or because an option was set by a client... is it a setting or a variable?

* making changes to messages is a bit complicated, because they evolved over different message formats.


Changes Done to Address Pain Points
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* use importlib from python, much more standard way to register plugins.
  now syntax errors will be picked up just like any other python module being imported,
  with a reasonable error message.

* no strange decoration at end of plugins (self.plugin = , etc... just plain python.)

* The strange choice of *parent* as a place for storing settings is puzzling to people.
  *parent* instance variable becomes *options*,  *self.parent* becomes *self.o*
   
* plural event callbacks replace singular ones:

  *  after_accept(self,worklist) replaces on_message(self,parent)
  *  after_work(self,worklist) replaces on_part/on_file(self,parent)


* messages are just python dictionaries. fields defined by json.loads( v03 payload format )
  messages only contain the actual fields, no settings or other things...
  plain data.
 
* callbacks move messages between worklists. A worklist is just a list of messages. There are four:

  * worklist.incoming -- messages yet to be processed.
  * worklist.rejected -- message which are not to be further processed.
  * worklist.ok -- messages which have been successfully processed.
  * worklist.retry   -- messages for which processing was attempted, but it failed.

  could add others... significant number of applications for something like *deferred*

* acknowledgements done more pro-actively, as soon as a message is processed
  (for rejected or failed messages, this is much sooner than in v2.)

* add scoping mechanism to define plugin properties.

* properties fed to __init__ of the plugin,  parent is gone from the plugins, they should
  just refer to self.o for the options/settings they need. (self.o clearly separates options
  from working data.)

* command-line parsing using python standard argParse library.  Means that keywords no longer work
  with a single -.  Settling on standard use of -- for word based options, and - for abbrevs.
  examples:  Good: --config, and -c, BAD: -config --c .



Ship of Theseus
---------------

It might be that the re-factoring inherent in v03 results in a 
Ship of Theseus, where it works the same way as v02, but all
the parts are different... obviously a concern/risk... 
might be a feature.

Now that we are a good way throught the process, a
mapping of source code transcriptions between
the two versions, is clear:

+--------------------------+---------------------------+
| Version 2 file           | Version 3 file            |
+--------------------------+---------------------------+
| sr_config.py             | config.py                 |
+--------------------------+---------------------------+
| sr_instances.py          | sr.py for most mgmt.      |
|                          | instance.py single proc   |
|                          |                           |
+--------------------------+---------------------------+
| sr_consumer.py           | moth/__init__.py          |
|                          |                           |
| sr_amqp.py               | moth/amqp.py              |
|                          |                           |
| sr_message.py            |                           |
+--------------------------+---------------------------+
| sr_checksum.py           | integrity/                |
|                          |      __init__.py          |
| sum/*                    |      *                    |
+--------------------------+---------------------------+
| sr_cache.py              | flowcb/nodupe.py          |
+--------------------------+---------------------------+
| sr_retry.py              | flowcb/retry.py           |
|                          |                           |
|                          | diskqueue.py              |
+--------------------------+---------------------------+
| sr_post.py               | flowcb/gather/file.py     |
|                          |                           |
|                          | flow/post.py              |
+--------------------------+---------------------------+
| sr_poll.py               | flowcb/gather/remote.py   |
|                          |                           |
|                          | flow/poll.py              |
+--------------------------+---------------------------+
|                          | transfer/__init__.py      |
| sr_util.py/sr_proto      |  * transfer.Protocol      |
|                          |                           |
| sr_util.py/sr_transport  | flow/__init__.py          |
|                          |                           |
| sr_file.py               | transfer/file.py          |
|                          |                           |
| sr_ftp.py                | transfer/ftp.py           |
|                          |                           |
| sr_http.py               | transfer/http.py          |
|                          |                           |
| sr_sftp.py               | transfer/sftp.py          |
|                          |                           |
+--------------------------+---------------------------+
| plugins/                 | flowcb/  (v3 ones)        |
|                          |    plugins/ still there   |
|                          |    for v2 ones.           |
+--------------------------+---------------------------+
| overall flow             | flow/__init__.py          |
+--------------------------+---------------------------+
|                          |                           |
| sr_poll.py               | sr_flow.py                |
|                          |                           |
| sr_post.py               |                           |
|                          |                           |
| sr_subscribe.py          |                           |
|                          |                           |
| sr_shovel.py             |                           |
|                          |                           |
| sr_report.py             |                           |
|                          |                           |
| sr_sarra.py              |                           |
|                          |                           |
| sr_sender.py             |                           |
|                          |                           |
| sr_watch.py              |                           |
|                          |                           |
| sr_winnow.py             |                           |
|                          |                           |
+--------------------------+---------------------------+


Mappings
~~~~~~~~

v2->v3 instance variables::

    self.user_cache_dir --> self.o.cfg_run_dir

Changes needed in v2 plugins::

    from sarra.sr_util import --> from sarra import 



Dictionaries or Members for Properties?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There seems to be a tension between using class members and dictionaries
for settings.  members seem more convenient, but harder to manipulate,
though we have equivalent idioms. Argparse returns options as their own
members of this parsing object.  There is a hierarchy to reconcile:

* protocol defaults
* consumer defaults
* component defaults
* configuration settings (overrides)
* command line options (overrides)

resolving them to apply overrides, mais more sense as operations
on dictionaries, printing, saving loading, again makes more sense
as dictionaries.  In code, members are slightly shorter, and perhaps
more idiomatic:: 

   hasattr(cfg,'member') vs. 'member' in cfg (dictionary)

What makes more sense... Does it make any practical difference?
not sure... need to keep the members for places where
callbacks are called, but can use properties elsewhere, if desired.


Known Problems (Solved in v3)
-----------------------------

* passing of logs around is really odd. We didn't understand what 
  python logging objects were. Need to use them in the normal way.
  new modules are built that way...

  In new modules, use the logging.getLogger( __name__ ) convention, but
  often the name does not match the actual source file...  why?
  e.g. a log message from config.py parsing shows up like::

     2020-08-13 ...  [INFO] sarra.sr_credentials parse_file ... msg text...

  why is it labelled sr_credentials? no idea. 


* this weird try/except thing for importing modules... tried removing
  it but it broke parsing of checksums... sigh... have to spend time
  on specifically that problem. On new modules ( sarra.config, 
  sarra.tmpc.*, sr.py ) using normal imports. likely need to
  refactor how checksum plugin mechanism works then try again.

  totally refactored now. Integrity class is normal, and separate from flowcb.


Concrete Plan
-------------

Replace sarra/sr_config with sarra/sr_cfg2. The new sr_cfg2 uses argparse 
and a simpler model for config file parsing. This became config.py

make sr.py accept operations on subsets, so it becomes the unique entry point.
internalize implementation of all management stuff, declare etc...

HMPC - Topic Message Protocol Client... a generalization of the message
passing library with a simplified API.  abstracts the protocol differences
away. (This later became the Moth module.)

The method of testing is to make modifications and check them against the 
sr_insects v03_wip branch. In general, an un-modified sr_insects tests should
work, but since the logs change, there is logic being added on that branch
to parse v2 and v3 versions in the same way. Thus the v03_wip branch tests
are compatible with both stable and work-in-progress versions.

To get each component working, practice with individual unit tests, and then
get to static-flow tests.  Can also do flakey_broker. The work is only going
that far as all the components are converted. Once full conversion is achieved,
then will look at dynamic_flow.

Purpose is not a finished product, but a product with sufficient and 
appropriate structure so that tasks can be delegated with reasonable hope of success.


Done
----

The functionality of sr_amqp.py is completely reproduced in moth/amqp.py 
All the important logic is preserved, but it is transcribed into new classes. 
Should have identical failure recovery behaviour. But it doesn't  we have
static flow test passing, but the flakey broker, which tests such recovery,
is currently broken.

sr_cfg2.py was still a stub, it has a lot of features and options, but
it isn't clear how to expand it to all of them. the thing about instances
inheriting from configure... it is odd, but hard to see how changing that
will not break everything, plugin-wise... thinking about having defaults
distributed to the classes that use the settings, and having something
that brings them together, instead of one massive config thing.
renamed to config.py (aka: sarra.config) and exercising it with
sr.py.  It is now a complete replacement.

Replaced the sr_consumer class with a new class that implements the
General Algorithm describe in `Concepts <Concepts.rst#the-general-algorithm>`
This happenned and became the Flow Module, and *the General Algorithm* got 
renamed *the Flow Algorithm*. yes, that is now flow/ class hierarchy.
The main logic is in __init__, and actual components are sub-classes.

Thinking about just removing the sr\_ prefix from classes for replacements,
since they are in sarra directory anyways. so have an internal class 
sarra/instances, sarra/sarra <- replace consumer... This happenned
and became a place holder for progress, meaning that files with sr_
prefix in the name, that are not entry-points, indicate v2 code that
has not yet been retired/replaced.

Added configuration selection to sr.py (e.g. subscribe/\*) and 
*setup*, and *cleanup* options. 

add/remove/enable/disable/edit (in sr.py) done.

'log' dropped for now... (which log ?)

added list, show, and built prototype shovel... required
a instance (sets state files and logs) and then calls flow... 
flow/run() is visibly  the general algorithm,
shovel is a sub-class of flow.

Got a skeleton for v2 plugins working (v2wrapper.py)
implemented import-based and group oriented v3 plugin framework. ( #213 )

cache (now called noDupe) working.

re-wrote how the v3 callbacks work to use worklists, and then re-cast
cache and retry v2plugins as v3 callbacks themselves.

renamed message queue abstract class from tmpc to moth
(what does a Sarracenia eat?)

With shovel and winnow replaced by new implementations, it passes
the dynamic flow test, including the Retry module ported to v3, and
a number of v2 modules used as-is.

Completed an initial version of the sr_post component now (in v3: flowcb.gather.file.File)
Now working on sr_poll, which will take a while because it involve refactoring: sr_file, sr_http,
sr_ftp, sr_sftp into the transfer module

Mostly done sr_subscribe, which, in the old version, is a base class for all other components,
but in v3 is just the first component that actually downloads data. So encountering all
issues with data download, and flowcb that do interesting things. Mostly done, but 
flowcb not quite working.

sr_sarra was straightforward once sr_subscribe was done.  

re-implemented Transfer get to have conventional return value as the number of bytes 
transferred, and if they differ, that signals an issue.

sr_sender send now done, involved a lot more thinking about how to set new_ fields
in messages. but once that was done, was able to remove both the sender and sr_subscribe
(the parent class of most components) and allowed removal of sr_cache, sr_consumer, sr_file,
sr_ftp, sr_http, sr_message, sr_retry, and sr_sftp, sum/\*, sr_util.

That's the end of the most difficult part.  

There was one commit to reformat the entire codebase to PEP style using yapf3.
Now I have the yapf3 pre-commit hook that reformats changes so that the entire codebase
remains yapf3 formatted.

Also have written message rate limiting into core, so now have message_rate_min, and message_rate_max
settings that replace/deprecate v2 post_rate_limit plugin.


Worries Addressed
~~~~~~~~~~~~~~~~~

This section contains issues that were taken care of.  They were a bother for a while,
so noting down what the solution was.

* logging using __name__ sometimes ends up claiming to be from the wrong file.
  example::  

    2020-08-16 01:31:52,628 [INFO] sarra.sr_credentials set_newMessageFields FIXME new_dir=/home/peter/sarra_devdocroot/download

  set_newMessageFields is in config.py not sr_credentials... why it is doing that?
  Likely wait until all legacy code is replaced before tackling this.
  if this doesn't get fixed, then make it a bug report.

  fixed: note... the problem was that the logger declaration must be AFTER all 
  imports.  Concretely::

    logger = logging.getLogger( __name__ )

  must be placed after all imports.

* sr_audit ? what to do. Removed.

* all non entry_point sr_*.py files can be removed.
  remove sum sub-directory. sr_util.py


Accel Overhaul
~~~~~~~~~~~~~~

plugin compatiblity under review... decided to re-write the accel_* plugins for v3, and
change the API because the v2 one has fundamental deficiencies:

* the do_get api deals with failure by raising an exception... there is no checking
  of return codes on built-in routines...  It is possiby taken care of by try/except, 
  but would prefer for a normal program flow to be able to trace and
  report when an i/o failure happens (keep try/except to as small a scale as we can.)

* there is a highly... idiosyncratic nature of the do_get, for example in the v2 accel_scp,
  where it calls do_get, and then decides not to run and falls through to the built-in 
  one. This logic is rarely helpful, difficult to explain, and confusing to diagnose
  in practice.

Have re-written accel_wget, and accel_scp to the new api... working through static-flow
to test them. There is also logic to spot v2 invocations of them, and replace with v3
in the configuration. And the first attempt was quite convoluted... was not happy.
2nd attempt also... working on a third one.

Re-wrote again, just adding getAccelerated() to the Transfer API, so it is built-in
instead of being a plugin.  Any Transfer class can specify an accelerator and it
will be triggered by accel_threshold. https and sftp/scp accelerators are implemented.

DoneTodo
--------

Items from the TODO list that have been addressed.

* migrate sr_xattr.py to sarra/xattr.py (now called sarracenia/filemetadata.py)

* fix flakey_broker test to pass.

* update documentation... change everything to use sr3 entry point, yes done.
  (See transition point below.)

* consider transition, life with both versions... should sr.py --> sr3.py ? Yes. Done
  should we have a separate debian package with transition entry points
  (sr_subscribe and friends only included in compat package, and all)
  interactivity natively only happens through sr3?
  now called metpx-sr3

* log is added.

* edit is added.

* perhaps move the whole plugin thing up a level (get rid of directory)
  so Plugin becomes a class instantiated in sarra/__init__.py... puts
  plugins and built-in code on a more even level... for example how
  do plugin transfer protocols work?  thinking... This is sort of done
  now: plugin became flowcb. Integrity is removed from the hierarchy.
  Class extension is now a separate kind of plugin (via import)

* change default topic_prefix to v03.post done 2021/02

* change default topic_prefix to v03 done 2021/03

* change topic_prefix to topicPrefix done 2021/03

* Adjust Programmer's Guide to reflect new API. done 2021/02

* log incoherency between 'info' and logging.INFO prevents proper log control.
  FIXED 2021/02.

* add SSL support to moth/mqtt.py

* missing accelerators:  sftp.putAcc, ftp.putAc, ftp.getAc, file.getAc, 

* migrate sr_credentials.py to sarracenia/credentials.py.

* remove *post* from v03 topic trees. Done!

* cleanup entry points: sr_audit, sr_tailf, sr_log2save, 

* test with dynamic-flow.


After Parity: True Improvements
-------------------------------

* start re-writing some plugins, like unidata stuff to see how hard it is
  new interface should be a lot easier, but road testing is needed.

* MQTT Support (Done!)

* AMQP 1.0 support (SWIM support for Aviation exchange.)

* Consider replacing manual queues in moth with more pythonic Queue.
  How to decide.

* Replace sarracenia.flowcb.retry (transliteration of v2) with more pythonic. 
  write an alternate module for each implementation.
  Would want to implement multiple options and examine performance
  in high load situation. Options:
   * Queue + sequential file writing
   * persist-queue (single task like today.)
   * persist-queue (shared among all instances?)

* use this to implement cache sharing (copying of cache from processes with 
  vip to those without.) General feature makes switchovers much cleaner.
  peer_broker, peer_exchange.

  advertise  shovel/config/recently_received/ and have non vip holders subscribe...

  or permit substitution with memcached?
  Make a peerqueue wrapper class, wait... just have peers subscribe to peer output.

* True Async: Single timing loop for entire app. Requires a retry_queue for posting.
  * requires a place to store failed/deferred posts (a second retry queue.)
  * changing events to have "after_post" processing of to append to outbound retry queue.
  * Do we have logic, like outbound winnow, where as long as published once, ok?
  * MQTT reception is already async, just need to fix transmit.

* Multi-source (requires async):
  * allow >1 broker and post_broker to be specified, gather from all brokers, post to all brokers.
    effect of true async.

* re-write poll, 

  * remove listing files from implementation, just use NoDupe.py Tune nodupe for cases.
    we will just keep using v2 for old polls, and write new polls in v3, so don't worry about
    compat. They can never be vaguely similar... true/False? 

  * add walk to the Transfer protocols.  just call walk from a flowcb/gather/remote.py

  * use cache-sharing to avoid multiple polls. or just remove filtering in poll, use winnow?

* log could read all the log files, so it would work with multiple
  instances.


TODO
----

* added "missing defaults" message, examine list, and see if we should set them all.
  check_undeclared_options missing defaults: {'discard', 'exchange_split', 
  'pipe', 'post_total_maxlag', 'exchange_suffix', 'destination', 'inplace', 
  'report_exchange', 'post_exchange_split', 'set_passwords', 'declare_exchange', 
  'sanity_log_dead', 'report_daemons', 'realpath_filter', 'reconnect', 
  'post_exchange_suffix', 'save', 'pump_flag', 'cache_stat', 'declare_queue', 'restore', 
  'bind_queue', 'dry_run', 'source_from_exchange', 'retry_mode', 'poll_without_vip', 'header'}

* #369 ... clean shutdown

* figure out an AsyncAPI implementation for subscription at least.

* get partitioned file transfers working again.

* convert existing poll to poll0 ? old poll.

* alarm_set truncates to integers... hmm.. use setitimer instead? 

* outlet option is missing.

* vhost support needed.

* add directories?

* sr_poll active/passive bug #29

* realpath_filter is used by CMOI. Seems to be disappeared in v3. It's there in the C version.

* port rest of v02 plugins to v03 equivalents and add mappings in config.py,
  so that we have barely any v2's left.

* transfer/sftp.py remove file_index from implementation ( #367 ) depend on NoDupe.py

* poll, remove listing files from implementation, just use NoDupe.py Tune nodupe for cases.
  we will just keep using v2 for old polls, and write new polls in v3, so don't worry about
  compat. They can never be vaguely similar... true/False? 
  (equivalent to re-write poll above.)

* full async mode for MQP's. requires publish_retry functionality.
  (again in future plans above.)

* once full async mode available, allow multiple gathers and publishes.
  (again in future plans above.)

* #33 add hostname to default queue.

* #348 add statehost to .cache directory tree.



Not Baked/Thinking
------------------

Structural code things that are not settled, may change.
Probably need to be settled before having anyone else dive in.

* scopable properties for internal classes, like they exist for plugins.
  I think this is done.  Would have to document somewhere,
  testing and demoing at the same time.

* took the code required to implement set_newMessageFields verbatim from v2.
  It is pretty hairy... perhaps turn into a plugin, to get it out of the 
  main code? Don't think it will ever go away. It is fairly ugly, but 
  very useful and heavily used in existing configs. probably OK. 

* changing recovery model, so that all retry/logic is in main loop,
  and moth just returns immediately.  Point being could have multiple
  gathers for multiple upstreams, and get messages from whichever is
  live...
  also end up with a single loop that way... cleaner.
  likely equivalent to async mode mentioned above.

* *gather* as a way of separating having multiple input brokers.
  so could avoid needing a winnow, but just having a subscriber connect to 
  multiple upstreams directly.
  likely equivalent to async, and multi-gather.

* think about API by sub-classing flow... and having it auto-integrate
  with sr entry point... hmm... likely look at this when updating
  Programmer's Guide.

* more worklists? rename failed -> retry or deferred.  Add a new failed
  where failed represents a permanent failure. and the other represents
  to be retried later.

* `MQTT issues <mqtt_issues.rst>`_


FIXME/Deferred
--------------

The point of the main v3 work is to get a re-factor done to the point where
the code is understandable to new coders, so that tasks can be assigned.
This section includes a mix of tasks that can hopefully be assigned, 

FIXME are things left to the side that need to be seen to.


* **RELEASE BLOCKER** hairy.
  sr_watch does not batch things. It just dumps an entire tree.
  This will need to be re-wored before release into an iterator style approach.
  so if you start in a tree with a million files, it will scan the entire million
  and present them as a single in memory worklist.  This will have performance
  problems.  want to incrementally proceed though lists one 'prefetch' batch
  at a time.

  There is an interim fix to pretend it does batching properly, but the memory
  impact and delay to producing the first file is still there, but at least
  returns one batch at a time.

* **RELEASE BLOCKER** logs of sr_poll and sr_watch tend to get humungous way too quickly.

* try out jsonfile for building messages to post. can build json incrementally,
  so you do not need to delete the _deleteOnPost elements (can just skip over them)

* um... add the protocols.   mqtt and qpid-proton amqpv1

* make sure stop actually works... seeing strays after tests... but changing too much 
  to really know. need to check.

Transition
----------

Do not know if straightforward (Replacement) upgrade is a good approach. Will it be possible to test sarra 
sufficiently such that upgrades of entire pumps are possible? or will incremental (parallel) upgrades 
be required?

It depends on whether v3 will work as a drop-in replacement or not. There is some incompatibility
we know will happen with do_* plugins. If that is sufficiently well documented and easily
dealt with, then it might not be a problem. On the other hand, if there are subtle
problems, then a parallel approach might be needed.

What is easier for the analysts to deal with?

Replacement
~~~~~~~~~~~

The package has the same name as v2 ones (metpx-sarracenia) differing only in version number.
Installing the new replaces the old completely. This requires that the new version be equal
or better than the old in all aspects, or that installation be confined to test machines
until that point is reached.

This takes longer to get initial installation, but has much clearer demarcation (you know
when you are done.)


Parallel
~~~~~~~~

Name the package metpx-sarra3 and have the python class directory be sarra3 (instead of sarra.)
(also ~/.config/sr3 and ~/.cache/sr3. likely the .cache files must be different because
retry files have different formats? validate. ) So one can copy configurations from old to
new and run both versions in parallel. The central entry point would be sr3 (rather than
sr), and to avoid confusion the other entry points (sr_subscribe etc...) would be omitted
so that v2 code would work unchanged. Might require some tweaks to have the sr classes
ignore instances from the other versions.

This is similar to python2 to python3 transition. Allows deployment of v03 without having
to convert entirely to it. Allows running some components, and building maturity slowly
while others are not ready. It facilitates A:B testing, running the same configuration
with one version or the other without having the install or use a different machine,
facilitating verification of compatibility.

Conclusion
~~~~~~~~~~

Have implemented Parallel model, with APPNAME=sr3 ( ~/.config/sr3, ~/.cache/sr3 )
sr3\_ prefix replacing sr\_ for all commands, and changing the sarra Python class to
the full sarracenia name to avoid clashing python classes.



Incompatibilities
-----------------

There are not supposed to be any. This is a running list of things to fix or document.
breaking changes:


* in v3, use -- for full word options, like --config, or --broker.  In v2 you could use -config and -broker,
  but that will end badly in v3.  In the old command line parser, -config, and --config were the same, which 
  was idiosyncratic.  The new
  command line option parser is built on ArgParse, and interprets a single - as prefix a single option where the
  the subsequent letters are and argument.  Example

  -config hoho.conf  -> in v2 refers to loading the hoho.conf file as a configuration.

  in v3, it will be interpreted as -c (config) load the onfig.conf gile, and hoho.conf is part of some subsequent option.

* loglevel none -> loglevel notset (now passing loglevel setting directly to python logging module, none isn't defined.)

* log messages and output in interactive, will be completely different.

* dropped settings: use_amqplib, use_pika... replaced by separate per protocol implementation libraries. amqp uses the 'amqp' library which is neither of the above.

* dropping on_watch plugins. afaict, no-one uses them.  The way v03 works it would be an after_accept for a watch.
  makes more sense that way anyways.

* plugins that access internals of sr_retry need to be rewritten, as the class is now plugin/retry.py.
  the way to queue something for retry in current plugins is to append them to the failed queue.
  This is only an issue in the flow tests of sr_insects.

* do_download and do_send were 1st pass at *schemed* plugins, I think they should be deprecated/replaced
  by do_get and do_put. unclear whether there is a need for these anymore (download and send plugins are
  at wrong level of abstraction)

* do_download, do_send, do_get, do_put are *schemed* downloads... that is, rather than stacking so that
  all are called, they are registered for particular protocols.  in v2, for example accel_* plugins would
  register the "download" scheme. an on_message entry point would alter the scheme so that the do_* routine
  would be invoked. In v2, the calling signature for all plugins is the same (self, parent) but for
  these do_get and do_put cases, that is quite counter productive. so instead have a calling signature
  identical to built-in protocol get/put... src_file, dst_file, src_offset, dst_offset, len )
  Resolution: just implement new Transfer classes, does not naturally fit in flowcb.

* In v2, mirror default settings used to be False in all components except sr_sarra.
  but the mirror setting was not honoured in shovel, and winnow (bug #358) 
  this bug is corrected in v3, but then you notice that the default is wrong.
 
  In v3, the default for mirror is changed to True for all flows except subscribe, which
  is the least surprising behaviour given the default to False in v2.
   
* in v2, download does not check the length of a file while it is downloading.
  in v3, it does. as an example, when using sftp as a poll, ls will list the size of a symbolic link.
  When it downloads, it gets the actual file, and not the symlink, so the size is different.

  Example from flow test::

       2021-04-03 10:13:07,310 [ERROR] sarracenia.transfer read_writelocal util/writelocal mismatched file length writing FCAS31_KWBC_031412___39224.slink. Message said to expect 135 bytes.  Got 114 bytes.

  the file is 114 bytes, by the link path is 135 bytes... 
  both v2 and v3 download the file and not the link, but v3 produces this error message.
  Thinking about this one...  is it a bug in poll? 

* In v2, if you delete a file, and then re-create it, an event will be created.
  In v3, if you do the same, the old entry will be in the nodupe cache, and the event will be suppressed.
  I have noticed this difference, but not sure which version's behaviour is correct.
  it could be fixed, if we decide the old behaviour is right.


Features
--------

* All the components are now derived from the *flow* class, and run the general algorithm already
  designed as the basis of v2, but never implemented as such.

* The extension API is now vanilla python with no magic settings. just standard classes, using standard import mechanism.
  debugging should be much simpler now as the interpreter will provide much better error messages on startup.
  The v2 style plugins are now called *flow callbacks*, and there are a number of classes (integrity, moth, 
  transfer, perhaps flow) that permit extension by straightforward sub-classing. This should make it much
  easier to add additional protocols for transport and messages, as well checksum algorithms for new data types.

* sarra.moth class abstracts away AMQP, so messaging protocol becomes pluggable.

* use the sarracenia/ prefix (already present) to replace sr\_ prefix on modules.

* API access to flows. (so can build entirely new programs in python by subclassing.)

* properties/options for classes are now hierarchical, so can set debug to specific classes within app.

* sr ability to select multiple components and configurations to operate on.

* sr list examples is now used to display examples separate from the installed ones.

* sr show is now used to display the parsed configuration.

* messages are acknowledged more quickly, should help with throughput.

* FlowCB plugin entry_points are now based on groups of messages, rather than individual ones, allowing people
  to organize concurrent work.

* integrity (checksums) are now plugins.

* gather (inlet? sources of messages) are now plugins.

* added typing to options settings, so plugins can declare: size, duration, string, or list.


Coverage Failures in Flow Tests
===============================

This section lists some areas of poor coverage in the flow test, that became evident
when other testing done.

* product selection (subtopics)  The subtopic selection logic was not working properly
  (we were getting far too many messages) but issue was masked by client side selection.
  DONE (transform_flow)

* names changed (transformed) during download DONE ( transform_flow )

* default directory on accept_unmatch was wrong... DONE ( added to sender in transform_flow )

* HTTP with BASIC authentication (was broken in last v2 release.)

* shim library commands other than the one or two tested.

* file partitioning.

* md5sum behaviour (ie. content changes, but checksum remains the same.)


